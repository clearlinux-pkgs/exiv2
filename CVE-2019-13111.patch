From caa4e6745a76a23bb80127cf54c0d65096ae684c Mon Sep 17 00:00:00 2001
From: Kevin Backhouse <kev@semmle.com>
Date: Tue, 30 Apr 2019 09:26:18 +0100
Subject: [PATCH 1/6] Avoid negative integer overflow when `filesize <
 io_->tell()`.

This fixes #791.

[Note - removed binary image from patch]
---
 include/exiv2/webpimage.hpp             |   2 +-
 src/webpimage.cpp                       |  35 ++++++++++++++++--------
 test/data/issue_791_poc1.webp           | Bin 0 -> 28 bytes
 tests/bugfixes/github/test_issue_791.py |  27 ++++++++++++++++++
 4 files changed, 52 insertions(+), 12 deletions(-)
 create mode 100644 test/data/issue_791_poc1.webp
 create mode 100644 tests/bugfixes/github/test_issue_791.py

diff --git a/include/exiv2/webpimage.hpp b/include/exiv2/webpimage.hpp
index 6da08396..456b2122 100644
--- a/include/exiv2/webpimage.hpp
+++ b/include/exiv2/webpimage.hpp
@@ -93,7 +93,7 @@ namespace Exiv2 {
                              byte *header, long header_size);
         bool equalsWebPTag(Exiv2::DataBuf& buf ,const char* str);
         void debugPrintHex(byte *data, long size);
-        void decodeChunks(uint64_t filesize);
+        void decodeChunks(uint32_t filesize);
         void inject_VP8X(BasicIo& iIo, bool has_xmp, bool has_exif,
                          bool has_alpha, bool has_icc, int width,
                          int height);
diff --git a/src/webpimage.cpp b/src/webpimage.cpp
index 63ecad83..e66d577c 100644
--- a/src/webpimage.cpp
+++ b/src/webpimage.cpp
@@ -62,6 +62,14 @@ namespace Exiv2 {
 namespace Exiv2 {
     using namespace Exiv2::Internal;
 
+    // This static function is a temporary fix in v0.27. In the next version,
+    // it will be added as a method of BasicIo.
+    static void readOrThrow(BasicIo& iIo, byte* buf, long rcount, ErrorCode err) {
+      const long nread = iIo.read(buf, rcount);
+      enforce(nread == rcount, err);
+      enforce(!iIo.error(), err);
+    }
+
     WebPImage::WebPImage(BasicIo::AutoPtr io)
     : Image(ImageType::webp, mdNone, io)
     {
@@ -474,6 +482,7 @@ namespace Exiv2 {
 
     /* =========================================== */
 
+
     void WebPImage::readMetadata()
     {
         if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());
@@ -489,7 +498,7 @@ namespace Exiv2 {
         DataBuf chunkId(5);
         chunkId.pData_[4] = '\0' ;
 
-        io_->read(data, WEBP_TAG_SIZE * 3);
+        readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);
 
         const uint32_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian) + 8;
         enforce(filesize <= io_->size(), Exiv2::kerCorruptedMetadata);
@@ -497,7 +506,7 @@ namespace Exiv2 {
 
     } // WebPImage::readMetadata
 
-    void WebPImage::decodeChunks(uint64_t filesize)
+    void WebPImage::decodeChunks(uint32_t filesize)
     {
         DataBuf   chunkId(5);
         byte      size_buff[WEBP_TAG_SIZE];
@@ -509,9 +518,10 @@ namespace Exiv2 {
 
         chunkId.pData_[4] = '\0' ;
         while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {
-            io_->read(chunkId.pData_, WEBP_TAG_SIZE);
-            io_->read(size_buff, WEBP_TAG_SIZE);
+            readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);
+            readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);
             const uint32_t size = Exiv2::getULong(size_buff, littleEndian);
+            enforce(io_->tell() <= filesize, Exiv2::kerCorruptedMetadata);
             enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);
 
             DataBuf payload(size);
@@ -522,7 +532,7 @@ namespace Exiv2 {
                 has_canvas_data = true;
                 byte size_buf[WEBP_TAG_SIZE];
 
-                io_->read(payload.pData_, payload.size_);
+                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);
 
                 // Fetch width
                 memcpy(&size_buf, &payload.pData_[4], 3);
@@ -537,7 +547,7 @@ namespace Exiv2 {
                 enforce(size >= 10, Exiv2::kerCorruptedMetadata);
 
                 has_canvas_data = true;
-                io_->read(payload.pData_, payload.size_);
+                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);
                 byte size_buf[WEBP_TAG_SIZE];
 
                 // Fetch width""
@@ -558,7 +568,7 @@ namespace Exiv2 {
                 byte size_buf_w[2];
                 byte size_buf_h[3];
 
-                io_->read(payload.pData_, payload.size_);
+                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);
 
                 // Fetch width
                 memcpy(&size_buf_w, &payload.pData_[1], 2);
@@ -576,7 +586,7 @@ namespace Exiv2 {
                 has_canvas_data = true;
                 byte size_buf[WEBP_TAG_SIZE];
 
-                io_->read(payload.pData_, payload.size_);
+                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);
 
                 // Fetch width
                 memcpy(&size_buf, &payload.pData_[6], 3);
@@ -588,10 +598,10 @@ namespace Exiv2 {
                 size_buf[3] = 0;
                 pixelHeight_ = Exiv2::getULong(size_buf, littleEndian) + 1;
             } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_ICCP)) {
-                io_->read(payload.pData_, payload.size_);
+                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);
                 this->setIccProfile(payload);
             } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_EXIF)) {
-                io_->read(payload.pData_, payload.size_);
+                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);
 
                 byte  size_buff[2];
                 // 4 meaningful bytes + 2 padding bytes
@@ -672,7 +682,7 @@ namespace Exiv2 {
 
                 if (rawExifData) free(rawExifData);
             } else if (equalsWebPTag(chunkId, WEBP_CHUNK_HEADER_XMP)) {
-                io_->read(payload.pData_, payload.size_);
+                readOrThrow(*io_, payload.pData_, payload.size_, Exiv2::kerCorruptedMetadata);
                 xmpPacket_.assign(reinterpret_cast<char*>(payload.pData_), payload.size_);
                 if (xmpPacket_.size() > 0 && XmpParser::decode(xmpData_, xmpPacket_)) {
 #ifndef SUPPRESS_WARNINGS
@@ -705,6 +715,9 @@ namespace Exiv2 {
 
     bool isWebPType(BasicIo& iIo, bool /*advance*/)
     {
+        if (iIo.size() < 12) {
+          return false;
+        }
         const int32_t len = 4;
         const unsigned char RiffImageId[4] = { 'R', 'I', 'F' ,'F'};
         const unsigned char WebPImageId[4] = { 'W', 'E', 'B' ,'P'};
diff --git a/tests/bugfixes/github/test_issue_791.py b/tests/bugfixes/github/test_issue_791.py
new file mode 100644
index 00000000..c2ae8c8c
--- /dev/null
+++ b/tests/bugfixes/github/test_issue_791.py
@@ -0,0 +1,27 @@
+import system_tests
+
+
+class IntegerOverflowInWebpImageReadMetadata(
+        metaclass=system_tests.CaseMeta):
+    """
+    Regression test for the bug described in:
+    https://github.com/Exiv2/exiv2/issues/791
+
+    Due to an integer overflow bug (#791), this test triggers a 4GB
+    memory allocation. So the test will fail with a std::bad_alloc
+    exception if less than 4GB is available.  On Linux, you can use
+    `ulimit -v 4000000` to reduce the available memory to slightly
+    less than 4GB.
+    """
+    url = "https://github.com/Exiv2/exiv2/issues/791"
+
+    filename = system_tests.path(
+        "$data_path/issue_791_poc1.webp"
+    )
+    commands = ["$exiv2 $filename"]
+    stdout = [""]
+    stderr = ["""Exiv2 exception in print action for file $filename:
+corrupted image metadata
+"""
+]
+    retval = [1]
-- 
2.22.0

From 86816c0280869ed3caff301df17c6f5ffbbe8cce Mon Sep 17 00:00:00 2001
From: Kevin Backhouse <kev@semmle.com>
Date: Thu, 2 May 2019 22:24:19 +0100
Subject: [PATCH 2/6] Fix signed/unsigned mismatch.

---
 include/exiv2/webpimage.hpp |  2 +-
 src/webpimage.cpp           | 12 +++++++-----
 2 files changed, 8 insertions(+), 6 deletions(-)

diff --git a/include/exiv2/webpimage.hpp b/include/exiv2/webpimage.hpp
index 456b2122..bd8be56c 100644
--- a/include/exiv2/webpimage.hpp
+++ b/include/exiv2/webpimage.hpp
@@ -93,7 +93,7 @@ namespace Exiv2 {
                              byte *header, long header_size);
         bool equalsWebPTag(Exiv2::DataBuf& buf ,const char* str);
         void debugPrintHex(byte *data, long size);
-        void decodeChunks(uint32_t filesize);
+        void decodeChunks(long filesize);
         void inject_VP8X(BasicIo& iIo, bool has_xmp, bool has_exif,
                          bool has_alpha, bool has_icc, int width,
                          int height);
diff --git a/src/webpimage.cpp b/src/webpimage.cpp
index e66d577c..15069cb7 100644
--- a/src/webpimage.cpp
+++ b/src/webpimage.cpp
@@ -500,13 +500,14 @@ namespace Exiv2 {
 
         readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);
 
-        const uint32_t filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian) + 8;
-        enforce(filesize <= io_->size(), Exiv2::kerCorruptedMetadata);
+        const long filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian) + 8;
+        enforce(0 <= filesize, Exiv2::kerCorruptedMetadata);
+        enforce((size_t)filesize <= io_->size(), Exiv2::kerCorruptedMetadata);
         WebPImage::decodeChunks(filesize);
 
     } // WebPImage::readMetadata
 
-    void WebPImage::decodeChunks(uint32_t filesize)
+    void WebPImage::decodeChunks(long filesize)
     {
         DataBuf   chunkId(5);
         byte      size_buff[WEBP_TAG_SIZE];
@@ -517,10 +518,11 @@ namespace Exiv2 {
 #endif
 
         chunkId.pData_[4] = '\0' ;
-        while ( !io_->eof() && (uint64_t) io_->tell() < filesize) {
+        while (!io_->eof() && io_->tell() < filesize) {
             readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);
             readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);
-            const uint32_t size = Exiv2::getULong(size_buff, littleEndian);
+            const long size = Exiv2::getULong(size_buff, littleEndian);
+            enforce(0 <= size, Exiv2::kerCorruptedMetadata);
             enforce(io_->tell() <= filesize, Exiv2::kerCorruptedMetadata);
             enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);
 
-- 
2.22.0

From d20a0a7b5721b884f538575e0c7ff50d1e085935 Mon Sep 17 00:00:00 2001
From: D4N <dan.cermak@cgc-instruments.de>
Date: Mon, 6 May 2019 10:57:34 +0100
Subject: [PATCH 3/6] Update tests/bugfixes/github/test_issue_791.py

Co-Authored-By: kevinbackhouse <kev@semmle.com>
---
 tests/bugfixes/github/test_issue_791.py | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/tests/bugfixes/github/test_issue_791.py b/tests/bugfixes/github/test_issue_791.py
index c2ae8c8c..2c987237 100644
--- a/tests/bugfixes/github/test_issue_791.py
+++ b/tests/bugfixes/github/test_issue_791.py
@@ -21,7 +21,7 @@ class IntegerOverflowInWebpImageReadMetadata(
     commands = ["$exiv2 $filename"]
     stdout = [""]
     stderr = ["""Exiv2 exception in print action for file $filename:
-corrupted image metadata
+$kerCorruptedMetadata
 """
 ]
     retval = [1]
-- 
2.22.0

From 3faeaefbf51fea44e9aff124e8c13b09b9e36aaf Mon Sep 17 00:00:00 2001
From: Kevin Backhouse <kev@semmle.com>
Date: Mon, 6 May 2019 11:36:40 +0100
Subject: [PATCH 4/6] Improve portability of bounds checks.

---
 src/webpimage.cpp | 25 +++++++++++++++++++------
 1 file changed, 19 insertions(+), 6 deletions(-)

diff --git a/src/webpimage.cpp b/src/webpimage.cpp
index 15069cb7..e57918ed 100644
--- a/src/webpimage.cpp
+++ b/src/webpimage.cpp
@@ -40,6 +40,7 @@
 #include "tiffimage.hpp"
 #include "tiffimage_int.hpp"
 #include "convert.hpp"
+#include "safe_op.hpp"
 
 #include <cmath>
 #include <iomanip>
@@ -500,10 +501,15 @@ namespace Exiv2 {
 
         readOrThrow(*io_, data, WEBP_TAG_SIZE * 3, Exiv2::kerCorruptedMetadata);
 
-        const long filesize = Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian) + 8;
-        enforce(0 <= filesize, Exiv2::kerCorruptedMetadata);
-        enforce((size_t)filesize <= io_->size(), Exiv2::kerCorruptedMetadata);
-        WebPImage::decodeChunks(filesize);
+        const uint32_t filesize_u32 =
+            Safe::add(Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian), 8U);
+        enforce(filesize_u32 <= io_->size(), Exiv2::kerCorruptedMetadata);
+
+        // Check that `filesize_u32` is safe to cast to long.
+        enforce(filesize_u32 <= static_cast<size_t>(std::numeric_limits<long>::max()),
+                Exiv2::kerCorruptedMetadata);
+
+        WebPImage::decodeChunks(static_cast<long>(filesize_u32));
 
     } // WebPImage::readMetadata
 
@@ -521,8 +527,15 @@ namespace Exiv2 {
         while (!io_->eof() && io_->tell() < filesize) {
             readOrThrow(*io_, chunkId.pData_, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);
             readOrThrow(*io_, size_buff, WEBP_TAG_SIZE, Exiv2::kerCorruptedMetadata);
-            const long size = Exiv2::getULong(size_buff, littleEndian);
-            enforce(0 <= size, Exiv2::kerCorruptedMetadata);
+
+            const uint32_t size_u32 = Exiv2::getULong(size_buff, littleEndian);
+
+            // Check that `size_u32` is safe to cast to `long`.
+            enforce(size_u32 <= static_cast<size_t>(std::numeric_limits<long>::max()),
+                    Exiv2::kerCorruptedMetadata);
+            const long size = static_cast<long>(size_u32);
+
+            // Check that `size` is within bounds.
             enforce(io_->tell() <= filesize, Exiv2::kerCorruptedMetadata);
             enforce(size <= (filesize - io_->tell()), Exiv2::kerCorruptedMetadata);
 
-- 
2.22.0

From 3c818f49d9bea56757264615ea38e5887e77dd5f Mon Sep 17 00:00:00 2001
From: Kevin Backhouse <kev@semmle.com>
Date: Mon, 6 May 2019 11:48:56 +0100
Subject: [PATCH 5/6] Revert accidental whitespace change.

---
 src/webpimage.cpp | 1 -
 1 file changed, 1 deletion(-)

diff --git a/src/webpimage.cpp b/src/webpimage.cpp
index e57918ed..9e4a3e85 100644
--- a/src/webpimage.cpp
+++ b/src/webpimage.cpp
@@ -483,7 +483,6 @@ namespace Exiv2 {
 
     /* =========================================== */
 
-
     void WebPImage::readMetadata()
     {
         if (io_->open() != 0) throw Error(kerDataSourceOpenFailed, io_->path(), strError());
-- 
2.22.0

From 6a44698abcf44cc858832643366e25cd16b573b2 Mon Sep 17 00:00:00 2001
From: Kevin Backhouse <kev@semmle.com>
Date: Mon, 6 May 2019 11:55:26 +0100
Subject: [PATCH 6/6] Small change to comment.

---
 src/webpimage.cpp | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/webpimage.cpp b/src/webpimage.cpp
index 9e4a3e85..ea6041ef 100644
--- a/src/webpimage.cpp
+++ b/src/webpimage.cpp
@@ -504,7 +504,7 @@ namespace Exiv2 {
             Safe::add(Exiv2::getULong(data + WEBP_TAG_SIZE, littleEndian), 8U);
         enforce(filesize_u32 <= io_->size(), Exiv2::kerCorruptedMetadata);
 
-        // Check that `filesize_u32` is safe to cast to long.
+        // Check that `filesize_u32` is safe to cast to `long`.
         enforce(filesize_u32 <= static_cast<size_t>(std::numeric_limits<long>::max()),
                 Exiv2::kerCorruptedMetadata);
 
-- 
2.22.0

